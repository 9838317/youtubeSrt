<?xml version="1.0" encoding="utf-8" ?><transcript><text start="0.78" dur="4.048">This pair of videos covers NoSQL systems. The first video is going to give a</text><text start="4.828" dur="3.726">history and motivation for the topic, and the second video will give an overview of</text><text start="8.554" dur="4.599">some specific NoSQL solutions. But let me warn you right away, that the</text><text start="13.153" dur="3.348">area of NoSQL systems is changing rapidly, so I&amp;amp;#39;m going to avoid giving too</text><text start="16.501" dur="5.759">many details so that the videos don&amp;amp;#39;t get out of date too quickly.</text><text start="22.26" dur="2.94">Let&amp;amp;#39;s start by talking about the NoSQL name itself.</text><text start="25.2" dur="2.79">It&amp;amp;#39;s actually a little bit confusing and misleading, has a bit of a history to it</text><text start="27.99" dur="2.97">already, which we&amp;amp;#39;ll go through, and those who invented it might be regretting</text><text start="30.96" dur="3.773">it a bit. But let&amp;amp;#39;s pull it apart, and let&amp;amp;#39;s first</text><text start="34.733" dur="2.818">look at SQL. In the term NoSQL, SQL is actually not</text><text start="37.551" dur="3.792">talking about the SQL language. What it&amp;amp;#39;s talking about more generally is</text><text start="41.343" dur="3.111">traditional relational data base management systems, which do have the</text><text start="44.454" dur="5.446">SQL language, but have a whole bunch of other aspects to them as well.</text><text start="49.9" dur="2.774">Over the past decade or so, there have been a number of new data management and</text><text start="52.674" dur="5.436">analysis problems that have cropped up, and we&amp;amp;#39;ll talk about some of those.</text><text start="58.11" dur="3.332">Where a traditional relational database management system might not be the best</text><text start="61.442" dur="4.092">solution for those problems, and again we&amp;amp;#39;ll talk about that as well.</text><text start="65.534" dur="4.154">So, NoSQL termed when you take it apart to mean NoSQL, is saying that for</text><text start="69.688" dur="6.542">some problems, we might not want to use a traditional relational database system.</text><text start="76.23" dur="4.158">It&amp;amp;#39;s not talking about this Sequel language itself, not picking on that but</text><text start="80.388" dur="5.332">again Talking about the whole trappings of the traditional system.</text><text start="85.72" dur="3.648">Now while pretty much everyone agrees that for some problems, a traditional</text><text start="89.368" dur="3.876">relational database management system isn&amp;amp;#39;t the best solution, there are still</text><text start="93.244" dur="3.42">a whole lot of problems for which it is, and so people now like to say, well</text><text start="96.664" dur="6.856">Problems aren&amp;amp;#39;t exclusively solved by traditional relational database systems.</text><text start="103.52" dur="2.379">They might be solved by traditional database systems for some portion of</text><text start="105.899" dur="2.291">them. And by some other solution for other</text><text start="108.19" dur="3.957">portions of the problem. And for that reason, NoSQL has actually</text><text start="112.147" dur="4.071">come to mean, and this is now the accepted definition, not only SQL, but</text><text start="116.218" dur="4.623">again, with SQL itself actually referring to traditional relational database</text><text start="120.841" dur="5.06">management systems. So what&amp;amp;#39;s wrong with a traditional</text><text start="125.901" dur="3.298">relational database system? Well, the primary issue is that it&amp;amp;#39;s a</text><text start="129.199" dur="4.111">big package with all kinds of features. And in many cases, though having all</text><text start="133.31" dur="3.445">those features in one place is a great thing, but sometimes we don&amp;amp;#39;t need all of</text><text start="136.755" dur="5.055">the features and it can actually be advantageous to drop some of those.</text><text start="141.81" dur="3.14">Now, what are those features? I&amp;amp;#39;m going to wind all the way back to the</text><text start="144.95" dur="3.85">introductory video to these materials, where we talked about database management</text><text start="148.8" dur="3.64">systems and all the great things they provide.</text><text start="152.44" dur="4.34">And actually I&amp;amp;#39;ve copied this directly from my very first set of slides.</text><text start="156.78" dur="4.686">That tells us that a database management system provides great things, efficiency,</text><text start="161.466" dur="4.356">reliability, convenience, a safety multi-user, access to massive amounts of</text><text start="165.822" dur="4.428">persistent data. So let&amp;amp;#39;s analyze these adjectives a</text><text start="170.25" dur="3.706">little bit more. Let&amp;amp;#39;s start by talking about convenience,</text><text start="173.956" dur="3.828">and let me give 3 aspects of a traditional database system that lead to</text><text start="177.784" dur="4.716">its convenience to use for an application.</text><text start="182.5" dur="2.452">So here they are. A simple data model, declarative query</text><text start="184.952" dur="4.518">language and transaction guarantees. And these 3 components of a database</text><text start="189.47" dur="5.3">system are one of the reasons that they are really good for certain applications.</text><text start="194.77" dur="3.54">Because you can put your data in an understandable way, you can query it</text><text start="198.31" dur="4.31">using a language that&amp;amp;#39;s easy to write yet very powerful.</text><text start="202.62" dur="3.77">And you get guarantees about what happens if the system crashes or if multiple</text><text start="206.39" dur="5.01">users are using it at the same time. So the relational data model is great</text><text start="211.4" dur="2.282">because the data is organized into tables.</text><text start="213.682" dur="3.315">We have an understandable algebra over relations, and that algebra forms the</text><text start="216.997" dur="4.673">basis of the query language, and everything fits neatly into a package.</text><text start="221.67" dur="3.56">The problem comes when our data doesn&amp;amp;#39;t fit so neatly into that package.</text><text start="225.23" dur="3.422">And if we insist on using the relational model, and our data isn&amp;amp;#39;t very</text><text start="228.652" dur="3.835">relational, then there has to be some process of organizing the data before we</text><text start="232.487" dur="5.113">can say, load it into the tables of our system.</text><text start="237.6" dur="2.27">The SQL language is great because it&amp;amp;#39;s very powerful.</text><text start="239.87" dur="4.41">It includes selections, projections, joins aggregation, all kinds of set</text><text start="244.28" dur="3.522">operators. useful predicates and so on, but what if</text><text start="247.802" dur="3.458">that query language is much more than what we need?</text><text start="251.26" dur="3.315">Maybe we only need to do simple fetches of records based on, key values, for</text><text start="254.575" dur="2.752">example. In that case, using a system that</text><text start="257.327" dur="4.613">supports the complicated language, may be, again, more than we actually need.</text><text start="261.94" dur="4.41">And similarly, transaction guarantees are, terrific when we have lots of users</text><text start="266.35" dur="4.921">hitting a system at the same time. And we have very strict requirements on</text><text start="271.271" dur="4.104">consistency, but if our requirements are a lot less, even the weakest guarantees,</text><text start="275.375" dur="3.933">that are made by the traditional database systems might not be appropriate for</text><text start="279.308" dur="4.055">application. And we&amp;amp;#39;re going to see examples of all of</text><text start="283.363" dur="3.153">these things. So the next attribute, multi-user, ties</text><text start="286.516" dur="2.904">right into our discussion of transaction guarantees.</text><text start="289.42" dur="3.24">Again, for some applications, we might not need to maintain the level of</text><text start="292.66" dur="4.14">consistency when multiple users are operating on the database at the same</text><text start="296.8" dur="3.3">time, that traditional systems are designed for.</text><text start="300.1" dur="4.266">Next attribute, safety. safety is both from a, an authorization</text><text start="304.366" dur="3.492">standpoint and from an attacker&amp;amp;#39;s standpoint.</text><text start="307.858" dur="3.622">And you know safety is not that different a concern in these NoSQL type</text><text start="311.48" dur="2.9">applications than in traditional applications.</text><text start="314.38" dur="3.894">Although in some cases, the NoSQL solutions we&amp;amp;#39;re going to discuss are used</text><text start="318.274" dur="4.226">more to process data offline and in a batch mode, in which case safety in terms</text><text start="322.5" dur="3.267">of authorization or even attack is much less of an issue than say, a database</text><text start="325.767" dur="5.763">system that&amp;amp;#39;s sitting behind a deployed website.</text><text start="331.53" dur="3.64">Persistence is something that&amp;amp;#39;s provided by database systems, and persistence is</text><text start="335.17" dur="4.04">certainly something important in NoSQL type applications as well.</text><text start="339.21" dur="3.953">Although, for NoSQL, we&amp;amp;#39;ll see that files are often okay, as a storage mechanism</text><text start="343.163" dur="4.071">rather than specialized structures that are typically implemented in a database</text><text start="347.234" dur="3.643">system. Reliability, again is something we&amp;amp;#39;re</text><text start="350.877" dur="3.038">certainly going to want in any data management application, but again the</text><text start="353.915" dur="3.332">considerations are a little different in certain types of applications, say the</text><text start="357.247" dur="5.607">batch data analysis applications. Or it might be just okay to completely</text><text start="362.854" dur="4.926">redo the entire, say, processing of the data, where that wouldn&amp;amp;#39;t be the case if</text><text start="367.78" dur="4.47">you had an operational database sitting behind a website.</text><text start="372.25" dur="4">Now the last two adjectives, on the other hand, are on the other end of spectrum.</text><text start="376.25" dur="3.6">One of the reasons for NoSQL solutions is that the data being handled</text><text start="379.85" dur="3.42">these days is much, much more massive than the amount of data that the</text><text start="383.27" dur="5.36">traditional relational database systems were designed for.</text><text start="388.63" dur="3.64">part of the reason is that the cost of hardware&amp;amp;#39;s gone down and so people are</text><text start="392.27" dur="4.69">just saving much more data. and then again another reason of course</text><text start="396.96" dur="4.02">are websites such as Facebook and tweeter and so on that are just collecting data</text><text start="400.98" dur="4.403">from enormous numbers of users at enormous rates.</text><text start="405.383" dur="4.08">And those same websites, by the way, have efficiency requirements that are much,</text><text start="409.463" dur="5.447">much higher than we&amp;amp;#39;ve seen in the past. So we have these millions billions of, of</text><text start="414.91" dur="4.03">records, and we expect a response time of under a second for fairly complex</text><text start="418.94" dur="5.02">operations overloads. So again, these are areas where NoSQL</text><text start="423.96" dur="5.74">systems want to increase the adjectives where the, earlier ones, we want to sort</text><text start="429.7" dur="5.114">of decrease what they&amp;amp;#39;re offering. So, in some sense, you can almost think</text><text start="434.814" dur="3.38">of NoSQL systems as compromising on some of these earlier ones, in order to</text><text start="438.194" dur="5.156">boost some of the later ones. So with that motivation, now let&amp;amp;#39;s talk</text><text start="443.35" dur="3.435">about the NoSQL systems. So they are, as I&amp;amp;#39;ve said, an alternative</text><text start="446.785" dur="3.564">to a traditional relational database system for managing and analyzing large</text><text start="450.349" dur="3.641">amounts of data. At the highest level, here are the</text><text start="453.99" dur="3.24">attributes that are provided in NoSQL systems.</text><text start="457.23" dur="5.6">So first of all, a more flexible schema than the rigid relational model.</text><text start="462.83" dur="3.54">Second of all, and I really hesitate to say this, but they tend to be a bit</text><text start="466.37" dur="4.95">quicker and a bit cheaper to set up for a particular application.</text><text start="471.32" dur="4.512">Now that may change over time, but that&amp;amp;#39;s the word on the street as of this moment.</text><text start="475.832" dur="5.52">Third, as I already motivated, they are designed for massive scalability and that</text><text start="481.352" dur="5.28">means massive both in the amount of data and also with the efficiency of the</text><text start="486.632" dur="6.716">operations on that data. And lastly, they don&amp;amp;#39;t necessarily have</text><text start="493.348" dur="3.987">transactional guarentees. In general what they do is relax the</text><text start="497.335" dur="4.55">consistency that&amp;amp;#39;s offered by the system And, in turn, gain higher performance and</text><text start="501.885" dur="5.391">higher availability of the system. So these systems do tend to be used for</text><text start="507.276" dur="3.304">applications that have strict requirements, both in how fast they can</text><text start="510.58" dur="4.967">do things and in being up all the time. Now, of course, there&amp;amp;#39;s a downside, and</text><text start="515.547" dur="2.553">again this is just at the very highest level.</text><text start="518.1" dur="3.01">Different, NoSQL systems address things in different ways.</text><text start="521.11" dur="4.69">On the downside, they tend not to have a dec, declarative query language.</text><text start="525.8" dur="2.44">So one of the benefits of a traditional system is being able to write.</text><text start="528.24" dur="4.012">Add hot queries in a very nice high level language, change your mind about what you</text><text start="532.252" dur="3.953">want to write and make changes easily, explore the database in lots of different</text><text start="536.205" dur="3.717">ways just with these simple queries, so in those SQL systems, the lack of</text><text start="539.922" dur="4.189">declarative query language does mean that there&amp;amp;#39;s more direct programmig Involved</text><text start="544.111" dur="4.389">in manipulating the data and another downside is the relaxed consistency does</text><text start="548.5" dur="3.635">mean there are fewer guarantees, so for applications that have very strict that</text><text start="552.135" dur="3.54">need very strict guarantees about the consistency of the data or say the</text><text start="555.675" dur="4.012">serialized ability of operations on the data, no sequal systems are probably not</text><text start="559.687" dur="9.873">a good idea. So the remainder of the video is just</text><text start="569.56" dur="3.4">going to go through a set of examples to motivate, the cases where we might want</text><text start="572.96" dur="2.9">to use a NoSQL system and the reasons that it might be difficult to use a</text><text start="575.86" dur="4.485">traditional system. They&amp;amp;#39;re all sort of simplified made-up</text><text start="580.345" dur="3.215">examples, but I do think they give the overall idea.</text><text start="583.56" dur="4.158">So the first example is an application where we have a large number of logs of</text><text start="587.718" dur="5.222">web activity and we want to analyze those logs in various ways.</text><text start="592.94" dur="3.72">Let&amp;amp;#39;s assume that when a web log is written there&amp;amp;#39;s a set of records for each</text><text start="596.66" dur="3.54">access, and that record is going to report that a particular user with a</text><text start="600.2" dur="5.529">given user ID accessed a particular URL at a particular time.</text><text start="605.729" dur="3.672">And then we might have some additional information associated with that access,</text><text start="609.401" dur="3.726">maybe something about the user or whether it was converted into a purchase or where</text><text start="613.127" dur="4.203">the user went next. All kinds of possible things we might</text><text start="617.33" dur="3.3">want to include in there, and actually, that additional info might change over</text><text start="620.63" dur="3.898">time. So let&amp;amp;#39;s suppose that we&amp;amp;#39;re going to work</text><text start="624.528" dur="3.332">with our web log data in a traditional database system.</text><text start="627.86" dur="3.24">The first test then would be to get the data loaded into the system.</text><text start="631.1" dur="3.41">And this is one of the first problems with relational systems is that there</text><text start="634.51" dur="3.79">might be quite a bit of work involved in taking data like this that might not be</text><text start="638.3" dur="4.84">perfectly organized and getting it into a relational system.</text><text start="643.14" dur="4.26">For example, we might want to do some amount of data cleaning.</text><text start="647.4" dur="3.54">data cleaning refers to finding say errors, or is, inconsistencies in the</text><text start="650.94" dur="4.42">data, and resolving those. For example, maybe our time stamps are in</text><text start="655.36" dur="2.38">multiple formats and we need to resolve them.</text><text start="657.74" dur="3.942">Maybe some of our URLs are invalid. So, we go through a data cleaning</text><text start="661.682" dur="3.438">process. The next thing we might want to do is</text><text start="665.12" dur="5.08">some amount of data extraction. So let&amp;amp;#39;s take a look at this additional</text><text start="670.2" dur="2.59">information. So this might be in a structured,</text><text start="672.79" dur="3.35">semi-structured, or free text format, but if we&amp;amp;#39;re going to load into a database</text><text start="676.14" dur="3.4">system then we&amp;amp;#39;re probably going to need to extract the relevant fields from that</text><text start="679.54" dur="5.83">information and get that formatted so we can load it into a table.</text><text start="685.37" dur="3.416">We might also do some amount of verification, maybe checking that all the</text><text start="688.786" dur="3.599">URLs are valid,. And then finally we have to devise,</text><text start="692.385" dur="5.815">design some kind of schema, or specify a schema, and then get the data loaded in.</text><text start="698.2" dur="3.64">Now proponents of NoSQL systems will tell you &amp;amp;quot;Hey, you don&amp;amp;#39;t have to do any</text><text start="701.84" dur="3.54">of that. You can just do nothing and immediately</text><text start="705.38" dur="4.316">start operating on the data directly out of say the file where it&amp;amp;#39;s stored.</text><text start="709.696" dur="3.864">And that sort of comes back to the idea that you can get up and running more</text><text start="713.56" dur="4.66">quickly on a NoSQL system. Now of course, there&amp;amp;#39;s no free lunch or</text><text start="718.22" dur="3.622">pay me now pay me later. The reality is of course when you</text><text start="721.842" dur="3.696">actually start processing the data, you are going to have to embed somewhere in</text><text start="725.538" dur="5.232">there these same basic operations to get the data cleaned up and usable.</text><text start="730.77" dur="2.82">But those would occur during the processing of the data.</text><text start="733.59" dur="3.136">And if there&amp;amp;#39;s some portions of the data that you&amp;amp;#39;re not operating on, you can</text><text start="736.726" dur="4.944">just leave those in place without doing the clean up of that portion of the data.</text><text start="741.67" dur="3.14">Now, let&amp;amp;#39;s look at the type of operations we might want to preform over this data.</text><text start="744.81" dur="3.782">It might be very simple things. We might say just want to find all</text><text start="748.592" dur="4.598">records that correspond to a given user. Or maybe we want to find all accesses of</text><text start="753.19" dur="5.29">a given URL, or everything that happened at a particular point in time.</text><text start="758.48" dur="4.158">Now, none of these things require SQL, ooh, NoSQL, but of course, that&amp;amp;#39;s not</text><text start="762.638" dur="4.692">what NoSQL stands for. But these all just require finding you</text><text start="767.33" dur="3.67">know, a set of records based on a single value.</text><text start="771" dur="3.286">Or we might want to look for some special construct that appears inside the</text><text start="774.286" dur="4.204">additional information, which the SQL language, again, is not particularly</text><text start="778.49" dur="4.07">designed to do. The other thing to notice about all of</text><text start="782.56" dur="3.28">these operations is that they are highly parallelizable.</text><text start="785.84" dur="5.85">Each one of them, in fact, is just looking at the individual records.</text><text start="791.69" dur="4.275">We could do everything in parallel. And exploiting parallelism when you have</text><text start="795.965" dur="3.363">simple operations is one of the, important aspects of most NoSQL</text><text start="799.328" dur="4.538">solutions. Here&amp;amp;#39;s an operation I came up with</text><text start="803.866" dur="4.024">because it does look like it requires a relational joint.</text><text start="807.89" dur="5.34">Let&amp;amp;#39;s say that we want to find all pairs of users that have acessed the same URL.</text><text start="813.23" dur="3.17">In fact, back in the SQL videos, I gave several examples like this.</text><text start="816.4" dur="5.822">This is essentially a self-join over two instances of a table or, two instances of</text><text start="822.222" dur="4.198">the web logs. So this looks like maybe we actually do</text><text start="826.42" dur="3.3">need a SQL-like solution, but I&amp;amp;#39;m going to argue that this is actually kind</text><text start="829.72" dur="3.48">of a weird query, and it&amp;amp;#39;s fairly unlikely that we would be doing this one</text><text start="833.2" dur="4.443">on a regular basis. Now, let&amp;amp;#39;s make our data scenario</text><text start="837.643" dur="3.285">slightly more complicated. In addition to the web log, let&amp;amp;#39;s suppose</text><text start="840.928" dur="3.872">that we have separate records with information about users.</text><text start="844.8" dur="2.91">So we have the user ID, maybe the name, age, gender, and some other attributes of</text><text start="847.71" dur="3.68">the users. And now, suppose our task is to take a</text><text start="851.39" dur="7.19">given URL and determine the average age of the users who have accessed that URL.</text><text start="858.58" dur="3.96">Okay, well this is a very, I would argue, SQL-like query.</text><text start="862.54" dur="3.96">So it&amp;amp;#39;s nice in this case to have a language somewhat like SQL.</text><text start="866.5" dur="4.25">But I&amp;amp;#39;ll still say that some aspects of NoSQL solutions may be relevant to this</text><text start="870.75" dur="3.389">task, and in particular, it&amp;amp;#39;s the question of consistency.</text><text start="874.139" dur="4.012">If we&amp;amp;#39;re using, if we&amp;amp;#39;re analyzing a huge amount of data and we&amp;amp;#39;re just looking for</text><text start="878.151" dur="3.776">some type of average, some type of statistical information over that data it</text><text start="881.927" dur="5.223">might not be required that we have absolute consistency.</text><text start="887.15" dur="3.77">In fact it might even be okay if we count some accesses to URL&amp;amp;#39;s that were at a</text><text start="890.92" dur="3.77">certain time, and we completely missed some from an earlier time just because</text><text start="894.69" dur="5.53">the database might be fragmented and, and inconsistent.</text><text start="900.22" dur="4.002">And, that&amp;amp;#39;s, that&amp;amp;#39;s again probably okay for this application, so to summarize the</text><text start="904.222" dur="4.002">weblog application, it might be somewhat difficult to get web access records into</text><text start="908.224" dur="4.704">a relational database system. It might be easier to use them in their</text><text start="912.928" dur="3.242">filed format and extract the information when we need it.</text><text start="916.17" dur="4.73">many of the operations that we perform, maybe extremely simply, just fetching a</text><text start="920.9" dur="3.7">set of records based on a value, and also highly parallelizable.</text><text start="924.6" dur="3.828">And even for the more complicated analyses that we might do, we may not</text><text start="928.428" dur="6.062">need strict consistency accessing say, a very specific snapshot of the data.</text><text start="934.49" dur="3.304">Now let&amp;amp;#39;s take a look at another application, let&amp;amp;#39;s say the friends</text><text start="937.794" dur="3.54">relationship in a social network, which generates a graph when a user is</text><text start="941.334" dur="6.196">represented by nodes, and say the friend relation is represented by edges.</text><text start="947.53" dur="4.36">So each record is going to have 2 user ID&amp;amp;#39;s.</text><text start="951.89" dur="3.264">That says that one user is friends with another, and then we&amp;amp;#39;ll have separate</text><text start="955.154" dur="3.519">records with information about users, the user ID, maybe again their name, age and</text><text start="958.673" dur="4.126">gender and so forth. And let&amp;amp;#39;s imagine this is an extremely</text><text start="962.799" dur="2.826">large social graph. What kind of operations might we want to</text><text start="965.625" dur="2.817">perform? Well, one of them is to find all the</text><text start="968.442" dur="4.458">friends of the given user, and so that&amp;amp;#39;s pretty straightforward.</text><text start="972.9" dur="2.93">Again, we are just fetching the set of user 2&amp;amp;#39;s that are associated with a given</text><text start="975.83" dur="3.97">user 1. So not an operation that requires a</text><text start="979.8" dur="5.328">complicated query language. On the other hand what if we are looking</text><text start="985.128" dur="3.641">for all friends of friends of a given user.</text><text start="988.769" dur="4.621">Actually now, we do require a joint operation in order to do that.</text><text start="993.39" dur="4.032">And furthermore, what if we want to find all women friends of men friends of a</text><text start="997.422" dur="3.532">given user? In that case, we&amp;amp;#39;re going to need a</text><text start="1000.954" dur="3.969">couple instances of the friend relationship, and we&amp;amp;#39;re going to need to</text><text start="1004.923" dur="6.477">join that with a couple instances actually of the user information as well.</text><text start="1011.4" dur="3.36">So, this is starting to look more, a little bit more SQL-like.</text><text start="1014.76" dur="2.684">But, maybe we don&amp;amp;#39;t need the full power of the language, because we can see that</text><text start="1017.444" dur="3.976">there&amp;amp;#39;s a certain sort of pattern to the types of operations we&amp;amp;#39;re doing.</text><text start="1021.42" dur="4.02">And of course, the problem comes when we want friends, of friends, of friends, of</text><text start="1025.44" dur="4.015">a given user. In that case, we&amp;amp;#39;re doing large number of</text><text start="1029.455" dur="3.079">joins, and large numbers of joins tend not to be not that efficient in</text><text start="1032.534" dur="4.637">relational data base systems, even when you use recursive SQL.</text><text start="1037.171" dur="4.553">So, in addition to this type of operation being not necessarily suitable for SQL, a</text><text start="1041.724" dur="4.426">second attribute that we probably don&amp;amp;#39;t need again in this environment is</text><text start="1046.15" dur="4.477">consistency. because we probably don&amp;amp;#39;t care that much</text><text start="1050.627" dur="4.273">whether we get an exact snapshot of the database, if things are changing.</text><text start="1054.9" dur="5">Typically, for these types of analyses, approximate solutions are acceptable.</text><text start="1059.9" dur="3.894">So these types of operations suggest that we might want to have a special type of</text><text start="1063.794" dur="4.012">database system that&amp;amp;#39;s suitable for graph operations on very large scale, and in</text><text start="1067.806" dur="3.776">fact graph databases are one type of NoSQL solution that we will talk about in</text><text start="1071.582" dur="6.368">the next video. And finally, my last example is Wikipedia</text><text start="1077.95" dur="2.418">pages. If you think of Wikipedia, it&amp;amp;#39;s a large</text><text start="1080.368" dur="5.132">collection of documents, extremely large. And inside each document, there&amp;amp;#39;s</text><text start="1085.5" dur="3.09">typically a combination of some structured data inside boxes that has</text><text start="1088.59" dur="4.269">say, key valued pairs. And then on the structured data, which</text><text start="1092.859" dur="3.72">might be fairly large volumes of text, a type of task we might want to do is say</text><text start="1096.579" dur="4.14">retrieve the first paragraph, the text paragraph, in all pages where we look in</text><text start="1100.719" dur="4.02">the structure data and find out that the page is about a United States president,</text><text start="1104.739" dur="6.625">say before 1900. clearly this is not very suitable for</text><text start="1111.364" dur="4.422">loading into a relational database and querying in that fashion, again because</text><text start="1115.786" dur="5.014">of the mix of structured and unstructured information.</text><text start="1120.8" dur="5.56">And once more, consistency is probably not critical in this environment as well.</text><text start="1126.36" dur="3.484">As we&amp;amp;#39;ll see, another type of NoSQL solution is called the document database</text><text start="1129.844" dur="4.626">system which can be more appropriate for this type of application.</text><text start="1134.47" dur="3.412">So to summarize, NoSQL systems provide an alternative to using a traditional</text><text start="1137.882" dur="4.415">database management system for certain types of applications.</text><text start="1142.297" dur="3.894">NoSQL systems provide a flexible schema which can be useful when its not easy to</text><text start="1146.191" dur="4.039">get the data into a structured table format.</text><text start="1150.23" dur="2.71">They can be quicker and cheaper to set up.</text><text start="1152.94" dur="3.283">So you might be able to get going faster on actually analyzing your data and maybe</text><text start="1156.223" dur="3.207">for less cost. a bit debatable, but that&amp;amp;#39;s the word on</text><text start="1159.43" dur="3.44">the street right now. They do provide massive scalability.</text><text start="1162.87" dur="3.83">So they&amp;amp;#39;re generally used for very, very large applications.</text><text start="1166.7" dur="3.479">Often applications that don&amp;amp;#39;t require the amount of consistency that a traditional</text><text start="1170.179" dur="3.185">system provides, and by relaxing the amount of consistency, they&amp;amp;#39;ll give you</text><text start="1173.364" dur="4.89">better performance, higher availability. The downsides of the this system tend to</text><text start="1178.254" dur="2.53">be the lack of a declarative query language.</text><text start="1180.784" dur="3.396">That means more programming is generally involved when using the systems, and</text><text start="1184.18" dur="3.32">fewer guarantees are provided about consistency.</text><text start="1187.5" dur="4.26">In the next video we&amp;amp;#39;ll specific NoSQL solutions and how they embody the</text><text start="1191.76" dur="3.473">adjectives that I&amp;amp;#39;ve included here.</text></transcript>